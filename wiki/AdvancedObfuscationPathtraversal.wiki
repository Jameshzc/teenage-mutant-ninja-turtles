----
=Advanced Directory traversal filter bypassing=
----

A directory traversal (or path traversal) consists in exploiting insufficient security validation / sanitization of user-supplied input file names, so that characters representing "traverse to parent directory" are passed through to the file APIs. The goal of this attack is to order an application to access a computer file that is not intended to be accessible. This attack exploits a lack of security (the software is acting exactly as it is supposed to) as opposed to exploiting a bug in the code. 

== What really is a Path Traversal ==

A Path Traversal attack aims to access files and directories that are stored outside the web root folder. By browsing the application, the attacker looks for absolute links to files stored on the web server. By manipulating variables that reference files with “dot-dot-slash (../)” sequences and its variations, it may be possible to access arbitrary files and directories stored on file system, including application source code, configuration and critical system files, limited by system operational access control. The attacker uses “../” sequences to move up to root directory, thus permitting navigation through the file system. But what exactly is a Path Traversal vulnerability?  

A Path Traversal is two things:

  # An input validation vulnerability (e.g the application allows the dot-dot-slash characters to pass through).
  # An access control vulnerability (e.g. the application has access to the OS file system with high privileges).

*Note:* OWASP categorizes this type of attack as a hybrid attack (e.g. access control and input validation issue).

== Unicode / UTF-8 encoded directory traversal (The canonicalization problem) ==

UTF-8 was noted as a source of vulnerabilities and attack vectors by Bruce Schneier and Jeffrey Streifling. When Microsoft added Unicode support to their Web server, a new way of encoding ../ was introduced into their code, causing their attempts at directory traversal prevention to be circumvented, this technique can also be used to bypass Web Application Firewalls. 

Multiple percent encodings, such as:

  # %c1%1c
  # %c0%af

*Note:* The above characters translated into the / and \ characters.


== URI encoded directory traversal (The canonicalization problem again!) ==

Some web applications scan query string for dangerous characters such as:

..
..\
../

to prevent directory traversal. However, the query string is usually URI decoded before use. Therefore these applications are vulnerable to percent encoded directory traversal such as:

  # %2e%2e%2f which translates to ../
  # %2e%2e/ which translates to ../
  # ..%2f which translates to ../
  # %2e%2e%5c which translates to ..\

Percent encodings were decoded into the corresponding 8-bit characters by Microsoft webserver. This has historically been correct behavior as Windows and DOS traditionally used canonical 8-bit characters sets based upon ASCII. However, the original UTF-8 was not canonical, and several strings were now string encodings translatable into the same string. Microsoft performed the anti-traversal checks without UTF-8 canonicalization, and therefore not noticing that (HEX) C0AF and (HEX) 2F were the same character when doing string comparisons. Malformed percent encodings, such as %c0%9v was also utilized.

== Methods to prevent directory traversal ==

A possible algorithm for preventing directory traversal would be to:

  # Process URI requests that do not result in a file request, e.g., executing a hook into user code, before continuing below.
  # When a URI request for a file/directory is to be made, build a full path to the file/directory if it exists, and normalize all characters (e.g., %20 converted to spaces).
  # It is assumed that a 'Document Root' fully qualified, normalized, path is known, and this string has a length N. Assume that no files outside this directory can be served.
  # Ensure that the first N characters of the fully qualified path to the requested file is exactly the same as the 'Document Root'.
  # If so, allow the file to be returned.
  # If not, return an error, since the request is clearly out of bounds from what the web-server should be allowed to serve.
  # Check if the string contains '..' (two periods next to each other).

*Note:* Using a hard-coded predefined file extension to suffix the path may limit the scope of the attack to files of that file extension.